
# 从规模上看，有以下几个阶段

1. 内嵌代码：写好实现，直接给到import和使用，一般是common模块
2. SDK独立模块：封装好一个代码模块，在项目层直接引用
3. 独立服务进程：暴露内部RPC供调用，自己管理运行周期
4. 平台话：更规范的通信交互，加上各种MTL等

承接 基础框架的设想 一文，看具体到哪一个阶段，如微服务，就从http网关开始建设；如独立模块代码，从service层开始建设

从低往高构建DAO组件：

### 约定

- 数据库连接建立后，`gorm.DB` 必须保持为单例。
- 通过 `NewDAO(db)` 创建 DAO，`db` 来自原始 `db` 的克隆。
- gorm插件先行解决主从同步问题，乐观锁和版本机制都属于这里，而非数据平台，用强制的接口如Sync()来保证原子性
- 可更新的，继承gorm.Model外，也可以继承Udpateable()，有version字段，新增时从0开始


### 建表规范

###### MySQL
- 默认继承 `gorm.Model`，`deleted_at` 造成的列和索引浪费可以忽略不计。
- 每个表都有一个自增 ID（`gorm.Model` 已有），不与业务挂钩。每个业务都有自己的主表，有一个 `string` 类型的业务 ID，例如 users 表的 account（可以是 UUID、A12345，甚至是数字字符串如 50001）。
- **字段设计**：
  - 部分表可能包含 `status` 或 `type` 字段，建议用enum，业务层通过全局字典管理。
  - 若表中含有其他表的外键，则使用 `{table}_id` 格式，例如 `user_id` 表示 user 表的 ID。建议为外键字段创建 B-tree 索引，由 Service 层检查合法性，避免数据库负担过多。

###### MongoDB
- **适用场景**：适用于不需要事务、不需要强关联的表，例如：
  - 全局字典表：`label:"goldmind", value:"1", category:"game_type"`
  - 多语言对照表：`key: "tips", zh-cn:"提示", en:"message tip"`
  - 公共修改日志表：记录系统中的每一次增删改操作。
- **特点**：这些表通常不需要 ID 关联，没有外部关联，也不需要复杂的查询或统计。

#### 公共修改记录表设计

db_infos:  //需要手动添加，或框架中加入检测
{
  "name": "db-test1"
  "path": "database-addr:port",
  "type": "mysql",
  "extra": {  }	//未決定結構
}

change_logs:	結構要改，需要引入tx-id，因爲涉及多表修改事務，最好有關聯的ID和是否使用了事務
{
	"db_info_id": "bson.id"
	"table_name": "users"
	"data_id": 1234			//users表的主鍵ID
	"action": "update deleted_at"
	"contents": [{"field": "account", field_type:"string", "before": any, "after": any}]
	"create_time", unix()
}

//建立索引（TODO：db_info_id和table_name做联合索引，没有单独查的场景 ）
db.change_log.createIndex({ db_info_id: 1 });
db.change_log.createIndex({ table_name: 1 });
db.change_log.createIndex({ data_id: 1 });

### 基础接口示例
- **单条查询**：`Get(id) User`
- **条件查询**：`List(condition) []User`
- **分页查询**：`Page(condition) Pager<[]User>`
- **创建**：`Create(User)` 新增记录
- **更新**：`Update(User)` 修改记录，需实现 `Updatable()`
- **删除**：`Delete(id)` 软删除，对于非 `Updatable()` 的记录，执行物理删除


### 增删改



### 查询

orm结构
field-tag: `query:unique;exp=between;order=asc;`
exp: gt, ge, lt, le, eq, ne, nil, nnil, between([2]slice), in([n]slice)

`Option`
	DAO的可選插件，DAO的接口都接受插件參數 ...options
type Option func(daoDriver interface)


`Pager` ，用於分頁查詢，不受具體數據庫約束
Pager{
	no:1, 	//當前頁
	size:10, 	//每頁數據量
	count:3, 	//總數據量
	total:27	//總頁數
}

`QueryParam`，DAO層的查詢結構，内嵌Pager，不要將其他層的request混進來，request的查詢結構應該貼合業務，QueryParam偏向通用設計，甚至以ORM方式驅動，將request轉爲QueryParam是service的邏輯
interface QueryParam{
	Pager() Pager
	Unique() []string
	Order() []string
}
實現QueryParam的好處是確保查詢參數是struct，且具有一些規範參數

`Result`，查詢結果結構，内嵌PagerResp、List<T>分別對應分頁結果，全查結果，單個結果List(0)
Result{
	Pager
	List<T>
}

`Error`
	RecordNotFound，無論列表還是單個，不受具體數據庫約束，接口可決定是否嚴格返回錯誤，用Option形式，
		例如：userDao.Get(1, ...option) => RequiredOption -> if (notFound){ return RecordNotFound }




注意区分API层和DAO层的error，以下是数据平台API层的Error
Error{
	Code: 200
	Msg: "my err msg"	//非必須
	Data: error-ref		//内部Log，不到API層
}
200:		ok，正常，不是錯誤，只是缺省設置
400:		record not found
500:		internal error
600:		外部組件錯誤，如mysql, redis等
700:		外部請求錯誤，通常是第三方API
701:		外部請求無回應
702:		外部請求回應數據解析錯誤
