承接 基础框架底层 一文

# Http网关

關於封裝 HttpServer 的一些約定

1. 使用gin做基礎框架
2. middleware要有以下内容，且支持多選，有公共的context作爲收納基礎
	1. recovery() 崩潰處理，包含公共日志記錄（時間、路徑、參數等），延申 -> 公共日志組件（格式定義）
	2. jwt()，用jwt做身份校验
	3. file() 用於multiform-part, 要修改content-type等header參數
	4. 集成validate和shouldBind，需要一個公共路由注冊Request{}，讓handler直接轉型即可使用
4 公共的Handler() ? 可以封裝各種請求返回格式，不用寫很多冗餘代碼，專注於 業務處理
5 導入和上傳，區別在於，導入是需要讀取文件内容，上傳可能是客戶端傳到cdn，本質在於是否需要讀取處理

# Service 业务层

单独抽出这一层，初衷是期望实现读写分离、cache、事务等（包括分布式事务），它应该是一切逻辑和资源的总调度者，可以进行高度抽象

Service的説明：
	1、用於處理業務邏輯，是基礎的入口，向下管理多個DAO
	2、向下管理多個DAO，完全和數據庫邏輯分離，不耦合跨庫跨表
	3、若需要處理複雜關聯查詢，自己關聯特殊的DAO，這種DAO不歸屬任何業務表，但是專門處理整合數據
	4、不一定非要有DAO，只要是處理業務相關邏輯，都應歸類到此

# DAO层

1. 用于描述数据在数据库中的结构，进行公共抽象，涵盖 MySQL、Mongo 等数据库，提供统一接口。
2. 另一种 Cache-DAO 用于描述数据在 Redis 中的结构和关系，与常规 DAO 互相独立，接口不同。
3. 每个 DAO 对应一张数据表和若干公共接口，例如 UserDAO 对应 user_detail 表或 users 表。



## 基础接口示例
- **单条查询**：`Get(id) User`
- **条件查询**：`List(condition) []User`
- **分页查询**：`Page(condition) Pager<[]User>`
- **创建**：`Create(User)` 新增记录
- **更新**：`Update(User)` 修改记录，需实现 `Updatable()`
- **删除**：`Delete(id)` 软删除，对于非 `Updatable()` 的记录，执行物理删除



## 关于跨表关联查询
涉及跨表的关联查询（如 JOIN、UNION、WITH 等）抛给上层 Service 处理。

## 核心理念：约定优于配置
- **固定命名**：`page`、`total`、`count` 等变量或名称固定，贯穿始终，无需额外字典或迁就其他需求。
- **公共约定区**：先定义公共约定区，确保一致性。



### 数据库支持
- 根据 MySQL 或 MongoDB 做不同 DAO 实现，支持切换使用。
- MySQL 字段：`id(uint)`、`create_time(datetime)`

## DAO 的使用


## 关于同步
- **问题**：MySQL 主从同步可能导致问题，例如数据查询时 `status=1`，修改为 `2` 后，从库尚未同步完成，仍查询到 `1`，可能触发错误。
- **解决方案**：
  - 数据划分可修改的标签，如接口 `Updateable()`，继承字段 `version int`。
  - 每次修改时判断原版本号，并递增数字，采用乐观锁机制：`update ... where version = {old}`。
  - 同时记录公共修改日志。
  - 在 `NewDAO()` 时，可指定主从，默认使用主库。
- **解决方案（新）**
  - 用gorm的主从插件，其他数据库暂不考虑同步（或者本身支持集群同步）

## 總結，需要框架完成的規範化作業

1、同步
	mysql主从、热双；采用gorm插件

2、sync数据版本
	數據修改時，記錄Log，還有樂觀鎖等, version int 字段，事务内尝试一定次数的查询

	NewMysqlDAO是最基礎的接口，所有Dao的建立都要調用它，會克隆原始DB
	DAO的Update接口或者需要引入AOP的概念，即增加middleware的方式，可以根據指定tag，完成對需要修改部分字段的判斷，以及原數據的對比，這樣才能寫change_log，middleware的好處是可插拔，gorm應該也有相關的hook提供

3、空值更新
User{
	Score int
	Name string
}
問題：假如user.Score = 0，在gorm更新時會忽略score的更新，造成預期錯誤
方案：使用指針結構
User{
	*Score int
	*Name string
}
這樣在update的時候，一定會指明需要更新的字段，但是要解決空指針以及開發流暢度的問題
不能使用Save()方法，因爲它會更新所有字段
然而在衆多實際項目中，都不會采用指針結構字段，因爲增加了複雜度和使用風險，反而偏向用 map[string]interface{} 避免零值更新